---
title: "NARFCS sensitivity analysis"
author: "Janick Weberpals"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{NARFCS sensitivity analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  dpi = 150,
  fig.width = 6,
  fig.height = 4.5
  )
```

```{r setup}
# basic setup
library(smdi)
suppressPackageStartupMessages(library(mice))
suppressPackageStartupMessages(library(dplyr))
```

# Sensitivity analysis for `MNAR(value)`

As we have seen earlier, if the missingness mechanism of an important covariate, such as a strong partially observed confounder, truly follows either a missing completely at random (MCAR) or a missing not at random *value* (MNAR[value]) scenario, the distinction between the two can turn out very difficult. This can have serious consequences since covariates that follow a true MNAR(value) mechanism may severely bias the effect estimation of an exposure of interest.

In reality, we will not be able to know 100% what the true missingness mechanism is and there may always be some residual uncertainty in case of MNAR(value). On the positive side, however, Leacy and Moreno-Betancur et al.[^1] have proposed a useful procedure to impute multivariable missing data under MNAR(value) conditions. By definition, under a MNAR(value) mechanism, the true (but unobserved) values of a variable systematically differ from the observed values. The idea of the not at random fully conditional specification (NARFCS) sensitivity analysis is to specify an imputation model containing a sensitivity parameter **ùõÖ** that reflects this systematic departure from a missing at random (MAR) mechanism.

[^1]: Tompsett, D. M., Leacy, F., Moreno-Betancur, M., Heron, J., & White, I. R. (2018). On the use of the not-at-random fully conditional specification (NARFCS) procedure in practice. *Statistics in Medicine*, **37**(15), 2338-2353. [doi:10.1002/sim.7643](https://doi.org/10.1002/sim.7643).

## Illustrative example

For example, the `age` of patients below a certain age cut-off may be systematically less frequently recorded. Despite this, `age` may still be an important predictor for the initiation of the treatment of interest and simultaneously an import prognostic variable for the outcome (time to death due to any reason [overall survival] in this example).

For simplicity, we don't assume any other missing covariates for now. In order to introduce an MNAR(value) mechanism for the `age` covariate, we:

* Determine a [missingess pattern](https://rianneschouten.github.io/mice_ampute/vignette/ampute.html#Patterns), in which only `age` will be set to missing
* Create a [weight vector](https://rianneschouten.github.io/mice_ampute/vignette/ampute.html#Weights), in which only `age` itself  (by a non-zero value) is the linear predictor for the probability of observations becoming missing
* Specify a type of logistic probabillity distribution for the missingness weights, so that cases with low weighted sum scores (i.e. younger `age`) will have a larger probability of becoming incomplete
* Define an overall missingness proportion of ~40%

```{r}
# load complete dataset
smdi_data_complete <- smdi::smdi_data_complete %>% 
  fastDummies::dummy_columns(
    select_columns = "ses_cat",
    remove_most_frequent_dummy = TRUE,
    remove_selected_columns = TRUE
  )

# determine missingness pattern
age_col <- which(colnames(smdi_data_complete)=="age_num")
miss_pattern <- rep(1, ncol(smdi_data_complete))
miss_pattern_age <- replace(miss_pattern, age_col, 0)

# weights to compute missingness probability
# covariate itself is only predictor
miss_weights_mnar_v <- rep(0, ncol(smdi_data_complete))
miss_weights_mnar_v <- replace(miss_weights_mnar_v, age_col, 1)

miss_prop_age <- .3

set.seed(42)
smdi_data_complete_mnar_v <- mice::ampute(
  data = smdi_data_complete,
  prop = miss_prop_age,
  mech = "MNAR",
  patterns = miss_pattern_age,
  weights = miss_weights_mnar_v,
  bycases = TRUE,
  type = "LEFT"
  )$amp
```

## Visual comparison

If we plot the direct comparison of `age` distributions between the original data and the data with complete cases after removing those who have a missing value following an MNAR(value) mechanism, we can observe the systematic difference in the two datasets.

```{r, warning=FALSE}
# plot
dplyr::bind_rows(
  smdi_data_complete %>% dplyr::select(age_num) %>% dplyr::mutate(dataset = "Complete"),
  smdi_data_mnar_v %>% dplyr::select(age_num) %>% dplyr::mutate(dataset = "MNAR(value)")
  ) %>% 
  ggplot2::ggplot(ggplot2::aes(x = dataset, y = age_num)) +
  ggplot2::geom_violin() +
  ggplot2::geom_boxplot(width = 0.3) +
  ggplot2::stat_summary(
    fun = "mean",
    geom = "pointrange",
    color = "red"
      ) +
  ggplot2::labs(
    y = "Age [years]",
    x = "Cohort"
  ) +
  ggplot2::theme_bw()
```

## `smdi` diagnostics

> TO DO

## Comparing treatment effect estimates

We can now compare and estimate the bias caused by the 40% of MNAR(value) missing values.

First, we specify a general outcome model.

```{r}
# outcome model (see data generation script)
cox_lhs <- "survival::Surv(eventtime, status)"
covariates <- smdi_data_complete %>% 
  dplyr::select(-c(exposure, eventtime, status)) %>% 
  names()

cox_rhs <- paste(covariates, collapse = " + ")
cox_form <- as.formula(paste(cox_lhs, "~ exposure +", cox_rhs))

cox_form  
```

Next, we compute the true Hazard Ratio (HR), the complete case HR and the standard *mice* multiple imputation HR.

```{r}
# true outcome model
cox_fit_true <- survival::coxph(cox_form, data = smdi_data_complete) %>% 
  broom::tidy(exponentiate = TRUE, conf.int = TRUE) %>% 
  dplyr::filter(term == "exposure") %>% 
  dplyr::select(term, estimate, conf.low, conf.high, std.error) %>% 
  dplyr::mutate(analysis = "True estimate")
 
# complete case analysis
cox_fit_cc <- survival::coxph(cox_form, data = smdi_data_mnar_v) %>% 
  broom::tidy(exponentiate = TRUE, conf.int = TRUE) %>% 
  dplyr::filter(term == "exposure") %>% 
  dplyr::select(term, estimate, conf.low, conf.high, std.error) %>% 
  dplyr::mutate(analysis = "Complete case analysis")

# Multiple imputation (predictive mean matching)
cox_fit_imp <- mice::mice(
  data = smdi_data_mnar_v,
  seed = 42, 
  print = FALSE
  ) %>%
  with(
    expr = survival::coxph(formula(paste(format(cox_form), collapse = "")))
    ) %>% 
  mice::pool() %>% 
  summary(conf.int = TRUE, exponentiate = TRUE) %>% 
  dplyr::filter(term == "exposure") %>% 
  dplyr::select(term, estimate, conf.low = `2.5 %`, conf.high = `97.5 %`, std.error) %>% 
  dplyr::mutate(analysis = "Multiple imputation")

forest <- dplyr::bind_rows(cox_fit_true, cox_fit_cc, cox_fit_imp) %>% 
  dplyr::mutate(analysis = factor(analysis, levels = c("True estimate", "Complete case analysis", "Multiple imputation"))) %>% 
  ggplot2::ggplot(ggplot2::aes(y = forcats::fct_rev(analysis))) +
  ggplot2::geom_point(ggplot2::aes(x = estimate), shape = 15, size = 3) +
  ggplot2::geom_errorbar(ggplot2::aes(xmin = conf.low, xmax = conf.high)) +
  ggplot2::geom_vline(xintercept = 1, linetype = "dashed") +
  ggplot2::labs(x = "Hazard ratio (95% CI)", y= "") +
  ggplot2::theme_bw()

table <- dplyr::bind_rows(cox_fit_true, cox_fit_cc, cox_fit_imp) %>% 
  dplyr::select(-term) %>% 
  dplyr::relocate(analysis, .before = estimate) %>% 
  dplyr::mutate(dplyr::across(tidyselect::where(is.numeric), ~round(.x, 2)))

gridExtra::grid.arrange(gridExtra::tableGrob(table, rows = NULL), forest)
```

As we can observe, the multiple imputation approach would have led to a wrong conclusion

## NARFCS imputation

As mentioned above, the true (but unobserved) values of a variable systematically differ from the observed values and this difference is reflected in the sensitivity parameter **ùõÖ**. More specifically, the interpretation of **ùõÖ** would be the difference in the distribution of missing and observed `age_num` values conditional on other covariates. Hence, for continuous covariates (like in our example) it would be the difference in mean conditional on `r toString(paste0(covariates[-1], collapse = " + "))`. Since our data generation model did not specifiy any interactions or relationships between covariates, we can simplify this here a little and just take the crude difference in means.

```{r}
# compute the conditional mean difference in age 
# between dataset with complete observations
# and dataset with partially observed age covariate
lm_form <- as.formula(paste("age_num ~ complete_dataset + exposure + ", paste(covariates[-1], collapse = "+")))

data_combined <- rbind(
  smdi_data_complete %>% dplyr::mutate(complete_dataset = 1), 
  smdi_data_mnar_v %>% dplyr::mutate(complete_dataset = 0)
  )

cond_mean_diff <- lm(lm_form, data = data_combined)$coefficients[["complete_dataset"]]
cond_mean_diff
```

If in reality, we would know this sensitivity parameter, we could easily plug it into our NARFCS.

```{r}
# initialize method vector
method_vector <- rep("", ncol(smdi_data_mnar_v))
                    
# columns for narfcs imputation with sensitivity parameter
mnar_imp_method <- which(colnames(smdi_data_mnar_v) == "age_num")

# update method vector
method_vector <- replace(x = method_vector, list = c(mnar_imp_method), values = c("mnar.norm"))

# mnar model specification
mnar_blot <- list(age_num = list(ums = toString(cond_mean_diff)))

narfcs_imp <- mice::mice(
  data = smdi_data_mnar_v,
  method = method_vector,
  blots = mnar_blot,
  seed = 42, 
  print = FALSE
  ) %>% 
  with(
    expr = survival::coxph(formula(paste(format(cox_form), collapse = "")))
    ) %>% 
  mice::pool() %>% 
  summary(conf.int = TRUE, exponentiate = TRUE) %>% 
  dplyr::filter(term == "exposure") %>% 
  dplyr::select(term, estimate, conf.low = `2.5 %`, conf.high = `97.5 %`, std.error) %>% 
  dplyr::mutate(analysis = "NARFCS imputation")

forest <- dplyr::bind_rows(cox_fit_true, cox_fit_cc, cox_fit_imp, narfcs_imp) %>% 
  dplyr::mutate(analysis = factor(analysis, levels = c("True estimate", "Complete case analysis", "Multiple imputation", "NARFCS imputation"))) %>% 
  ggplot2::ggplot(ggplot2::aes(y = forcats::fct_rev(analysis), color = ifelse(analysis == "NARFCS imputation", 'red', 'black'))) +
  ggplot2::geom_point(ggplot2::aes(x = estimate), shape = 15, size = 3) +
  ggplot2::geom_errorbar(ggplot2::aes(xmin = conf.low, xmax = conf.high)) +
  ggplot2::geom_vline(xintercept = cox_fit_true[[2]], linetype = "dashed") +
  ggplot2::labs(x = "Hazard ratio (95% CI)", y= "") +
  ggplot2::scale_color_identity() +
  ggplot2::theme_bw()

forest
```

## Tipping point analysis

But unfortunately, in reality we don't know the value of **ùõÖ**. Nevertheless, we want to make sure that whatever analytical decision we chose for our primary analysis (be it a complete case approach or an imputation approach), our results would not drastically change if the true underlying missingness mechanism was MNAR(value).

This is where the NARFCS sensitivity analysis comes in handy as it is also often used as a **tipping point analysis**, i.e. we model multiple NARFCS-specified imputation models over a range of realistic **ùõÖ** sensitivity parameters and evaluate if at any pre-specified **ùõÖ**, our confidence interval would cross a certain estimate threshold which would discard the global conclusion of our primary analysis.

```{r, fig.width=6}
# modeled over a range of deltas
narfcs_modeled <- function(i){
  
  # mnar model specification ('i' is delta parameter)
  mnar_blot <- list(age_num = list(ums = paste(i)))

  narfcs_imp <- mice::mice(
    data = smdi_data_mnar_v,
    method = method_vector,
    blots = mnar_blot,
    seed = 42, 
    print = FALSE
    ) %>% 
    with(
      expr = survival::coxph(formula(paste(format(cox_form), collapse = "")))
      ) %>% 
    mice::pool() %>% 
    summary(conf.int = TRUE, exponentiate = TRUE) %>% 
    dplyr::filter(term == "exposure") %>% 
    dplyr::select(term, estimate, conf.low = `2.5 %`, conf.high = `97.5 %`, std.error) %>% 
    dplyr::mutate(delta = i)
  
} 

narfcs_range <- lapply(
  X = seq(-25, 25, 1),
  FUN = narfcs_modeled
  )

narfcs_range_df <- do.call(rbind, narfcs_range)

reference_lines <- tibble::tibble(
  yintercept = c(1, cox_fit_true[[2]]),
  Reference = c("TRUE HR", "Complete model"),
  color = c("blue", "darkgreen")
  )

narfcs_range_df %>% 
  ggplot2::ggplot(ggplot2::aes(x = delta, y = estimate)) +
  ggplot2::geom_point() +
  ggplot2::geom_line() +
  ggplot2::geom_ribbon(ggplot2::aes(ymin = conf.low, ymax = conf.high), alpha = 0.15) +
  ggplot2::labs(x = "Sensitivity parameter Œ¥", y = "Hazard ratio (95% CI)") +
  ggplot2::scale_x_continuous(breaks = seq(-25, 25, 1), limits = c(-25, 25)) +
  ggplot2::scale_y_continuous(breaks = seq(0.6, 1.2, 0.1), limits = c(0.6, 1.2)) +
  ggplot2::geom_hline(ggplot2::aes(yintercept = yintercept, color = Reference), reference_lines) +
  ggplot2::scale_colour_manual(values = reference_lines$color) +
  ggplot2::theme_bw() +
  ggplot2::theme(legend.position="top")
```

# Multivariate missingness PD-L1 biomarker example

Now, we can do the same in our *missing" `smdi_data` dataset. However, this gets a little tricky since we have multiple missing covariates, each of which follow different missingness mechanisms. Here is again a quick overview of the missing variables using the `smdi_summarize()` function.

```{r}
smdi::smdi_data %>% 
  smdi::smdi_summarize()
```


# More on sensitivity analyses

For more information and helpful resources regarding sensitivity analyses for missing data, we recommend checking out the following links and manuscripts:

<https://stefvanbuuren.name/fimd/sec-sensitivity.html>

<https://amices.org/mice/reference/mice.impute.mnar.html>

<https://raw.githack.com/moreno-betancur/NARFCS/master/Vignette.html>

Tompsett, D. M., Leacy, F., Moreno-Betancur, M., Heron, J., & White, I. R. (2018). On the use of the not-at-random fully conditional specification (NARFCS) procedure in practice. Statistics in Medicine, 37(15), 2338-2353. <doi:10.1002/sim.7643> .

Van Buuren, S., Boshuizen, H.C., Knook, D.L. (1999) Multiple imputation of missing blood pressure covariates in survival analysis. Statistics in Medicine, 18, 681--694.
